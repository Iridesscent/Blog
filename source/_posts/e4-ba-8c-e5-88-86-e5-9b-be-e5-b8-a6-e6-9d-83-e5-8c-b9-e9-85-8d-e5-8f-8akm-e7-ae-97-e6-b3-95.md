---
title: 二分图带权匹配及KM算法
categories:
  - Algorithm
id: 161
tags:
  - Bipartite graph
  - Graph theory
date: 2016-03-12 14:06:35
---

原文出处：[Kuhn-Munkres算法（二分图最大权匹配）](http://www.cnblogs.com/kuangbin/archive/2012/08/19/2646535.html)

二分图如果是没有权值的，求最大匹配。则是用匈牙利算法求最大匹配。如果带了权值，求最大或者最小权匹配，则必须用KM算法。

其实最大和最小权匹配都是一样的问题。只要会求最大匹配，如果要求最小权匹配，则将权值取相反数，再把结果取相反数，那么最小权匹配就求出来了。

下面是从网上的博客摘抄的一些零散的总结。。。。。

**[二分图带权匹配与最佳匹配]**

什么是二分图的带权匹配？二分图的带权匹配就是求出一个匹配集合，使得集合中边的权值之和最大或最小。而二分图的最佳匹配则一定为**完备匹配**，在此基础上，才要求匹配的边权值之和最大或最小。二分图的**带权匹配与最佳匹配不等价，也不互相包含**。

这两个的关系比较悬乎。我的理解就是带权匹配是不考虑是不是完备，只求最大或最小权匹配。而最佳匹配则必须在完备匹配的基础上找最大或最小权匹配。

这两个还是结合具体题目比较好理解些。

&nbsp;

&nbsp;

KM算法是求最大权完备匹配，如果要求最小权完备匹配怎么办？方法很简单，只需将所有的边权值取其相反数，求最大权完备匹配，匹配的值再取相反数即可。

&nbsp;

KM算法的运行要求是**必须存在一个完备匹配**，如果求一个最大权匹配(不一定完备)该如何办？依然很简单，把不存在的边权值赋为0。

&nbsp;

KM算法求得的最大权匹配是**边权值和**最大，如果我想要**边权之积**最大，又怎样转化？还是不难办到，每条边权取自然对数，然后求最大和权匹配，求得的结果a再算出e^a就是最大积匹配。至于精度问题则没有更好的办法了。

&nbsp;

二分图最优匹配：对于二分图的每条边都有一个权（非负），要求一种完备匹配方案，使得所有匹配边的权和最大，记做最优完备匹配。（特殊的，当所有边的权为1时，就是最大完备匹配问题）

定义     设G＝&lt;V<sub>1</sub>，V<sub>2</sub>，E&gt;为二部图，|V<sub>1</sub>|≤|V<sub>2</sub>|，M为G中一个最大匹配，且|M|＝|V<sub>1</sub>|，则称M为V<sub>1</sub>到V<sub>2</sub>的**完备匹配**。

在上述定义中，若|V<sub>2</sub>|＝|V<sub>1</sub>|，则完备匹配即为**完美匹配**，若|V<sub>1</sub>|&lt;|V<sub>2</sub>|，则完备匹配为G中最大匹配。

KM算法是通过给每个顶点一个标号（叫做**顶标**）来把求最大权匹配的问题转化为求完备匹配的问题的。设顶点X<sub>i</sub>的顶标为A[i]，顶点Y<sub>i</sub>的顶标为B[i]，顶点X<sub>i</sub>与Y<sub>j</sub>之间的边权为w[i,j]。在算法执行过程中的任一时刻，对于任一条边(i,j)，A[i]+B[j]&gt;=w[i,j]始终成立，初始A[i]为与xi相连的边的最大边权，B[j]=0。KM算法的正确性基于以下定理：

<div>设 G(V,E) 为二部图， G'(V,E') 为二部图的子图。如果对于 G' 中的任何边&lt;x,y&gt; 满足， L(x)+ L(y)== W<sub>x,y</sub>，我们称 G'(V,E') 为 G(V,E) 的等价子图或相等子图（是G的生成子图）。</div>

**若由二分图中所有满足A[i]+B[j]=w[i,j]的边(i,j)构成的子图（称做<strong>相等子图**）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。</strong>

因为对于二分图的任意一个匹配，如果它包含于相等子图，那么它的边权和等于所有顶点的顶标和；如果它有的边不包含于相等子图，那么它的边权和小于所有顶点的顶标和（即不是最优匹配）。所以相等子图的完备匹配一定是二分图的最大权匹配。

&nbsp;

&nbsp;

该算法是通过给每个顶点一个标号（叫做顶标）来把求最大权匹配的问题转化为求完备匹配的问题的。设顶点Xi的顶标为A[ i ]，顶点Yj的顶标为B[ j ]，顶点Xi与Yj之间的边权为w[i,j]。在算法执行过程中的任一时刻，对于任一条边(i,j)，A[ i ]+B[j]&gt;=w[i,j]始终成立。
<div></div>
KM算法的正确性基于以下定理：
<div></div>
若由二分图中所有满足A[ i ]+B[j]=w[i,j]的边(i,j)构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。
<div></div>
首先解释下什么是完备匹配，所谓的完备匹配就是在二部图中，X点集中的所有点都有对应的匹配或者是
<div></div>
Y点集中所有的点都有对应的匹配，则称该匹配为完备匹配。
<div></div>
这个定理是显然的。因为对于二分图的任意一个匹配，如果它包含于相等子图，那么它的边权和等于所有顶点的顶标和；如果它有的边不包含于相等子图，那么它的边权和小于所有顶点的顶标和。所以相等子图的完备匹配一定是二分图的最大权匹配。
<div></div>
初始时为了使A[ i ]+B[j]&gt;=w[i,j]恒成立，令A[ i ]为所有与顶点Xi关联的边的最大权，B[j]=0。如果当前的相等子图没有完备匹配，就按下面的方法修改顶标以使扩大相等子图，直到相等子图具有完备匹配为止。
<div></div>
我们求当前相等子图的完备匹配失败了，是因为对于某个X顶点，我们找不到一条从它出发的交错路。这时我们获得了一棵交错树，它的叶子结点全部是X顶点。现在我们把交错树中X顶点的顶标全都减小某个值d，Y顶点的顶标全都增加同一个值d，那么我们会发现：
<div></div>
1）两端都在交错树中的边(i,j)，A[ i ]+B[j]的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。
<div></div>
2）两端都不在交错树中的边(i,j)，A[ i ]和B[j]都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。
<div></div>
3）X端不在交错树中，Y端在交错树中的边(i,j)，它的A[ i ]+B[j]的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。
<div></div>
4）X端在交错树中，Y端不在交错树中的边(i,j)，它的A[ i ]+B[j]的值有所减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。
<div></div>
现在的问题就是求d值了。为了使A[ i ]+B[j]&gt;=w[i,j]始终成立，且至少有一条边进入相等子图，d应该等于：
<div></div>
Min{A[ i ]+B[j]-w[i,j] | Xi在交错树中，Yi不在交错树中}。以上就是KM算法的基本思路。但是朴素的实现方法，时间复杂度为O(n4)——需要找O(n)次增广路，每次增广最多需要修改O(n)次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为O(n2)。实际上KM算法的复杂度是可以做到O(n3)的。我们给每个Y顶点一个“松弛量”函数slack，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边(i,j)时，如果它不在相等子图中，则让slack[j]变成原值与A[ i ]+B[j]-w[i,j]的较小值。这样，在修改顶标时，取所有不在交错树中的Y顶点的slack值中的最小值作为d值即可。但还要注意一点：修改顶标后，要把所有的不在交错树中的Y顶点的slack值都减去d。
<div></div>
Kuhn－Munkras算法流程：
<div></div>
(1)初始化可行顶标的值
<div></div>
(2)用匈牙利算法寻找完备匹配
<div></div>
(3)若未找到完备匹配则修改可行顶标的值
<div></div>
(4)重复(2)(3)直到找到相等子图的完备匹配为止

&nbsp;

&nbsp;

最后还是强调一点：

KM算法用来解决最大权匹配问题： 在一个二分图内，左顶点为X，右顶点为Y，现对于每组左右连接XiYj有权wij，求一种匹配使得所有wij的和最大。

也就是最大权匹配一定是完备匹配。如果两边的点数相等则是完美匹配。

如果点数不相等，其实可以虚拟一些点，使得点数相等，也成为了完美匹配。